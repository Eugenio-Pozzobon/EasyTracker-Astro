\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{package} \PYG{n+nn}{com.example.startracker}

\PYG{k}{import} \PYG{n+nn}{android.bluetooth.BluetoothAdapter}
\PYG{k}{import} \PYG{n+nn}{android.bluetooth.BluetoothDevice}
\PYG{k}{import} \PYG{n+nn}{android.bluetooth.BluetoothSocket}
\PYG{k}{import} \PYG{n+nn}{android.os.Bundle}
\PYG{k}{import} \PYG{n+nn}{android.os.Handler}
\PYG{k}{import} \PYG{n+nn}{android.os.Looper}
\PYG{k}{import} \PYG{n+nn}{android.os.Message}
\PYG{k}{import} \PYG{n+nn}{android.util.Log}
\PYG{k}{import} \PYG{n+nn}{androidx.lifecycle.LiveData}
\PYG{k}{import} \PYG{n+nn}{androidx.lifecycle.MutableLiveData}
\PYG{k}{import} \PYG{n+nn}{java.io.IOException}
\PYG{k}{import} \PYG{n+nn}{java.io.InputStream}
\PYG{k}{import} \PYG{n+nn}{java.io.OutputStream}
\PYG{k}{import} \PYG{n+nn}{java.util.*}
\PYG{k}{import} \PYG{n+nn}{kotlin.concurrent.thread}

\PYG{k+kd}{class} \PYG{n+nc}{BluetoothService} \PYG{p}{\PYGZob{}}

    \PYG{c+c1}{// Defines several constants used when transmitting messages between the}
    \PYG{c+c1}{// service and the UI.}
    \PYG{k+kd}{val} \PYG{n+nv}{MESSAGE\PYGZus{}READ}\PYG{p}{:} \PYG{k+kt}{Int} \PYG{o}{=} \PYG{l+m}{0}

    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}mmIsConnected} \PYG{o}{=} \PYG{n}{MutableLiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Boolean?}\PYG{o}{\PYGZgt{}}\PYG{p}{()}
    \PYG{k+kd}{val} \PYG{n+nv}{mmIsConnected}\PYG{p}{:} \PYG{n}{LiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Boolean?}\PYG{o}{\PYGZgt{}}
        \PYG{k}{get}\PYG{p}{()} \PYG{o}{=} \PYG{n}{\PYGZus{}mmIsConnected}

    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}calibratingCompass} \PYG{o}{=} \PYG{n}{MutableLiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Boolean}\PYG{o}{\PYGZgt{}}\PYG{p}{()}
    \PYG{k+kd}{val} \PYG{n+nv}{calibratingCompass}\PYG{p}{:} \PYG{n}{LiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Boolean}\PYG{o}{\PYGZgt{}}
        \PYG{k}{get}\PYG{p}{()} \PYG{o}{=} \PYG{n}{\PYGZus{}calibratingCompass}

    \PYG{k+kd}{var} \PYG{n+nv}{trackingStars} \PYG{o}{=} \PYG{n}{MutableLiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Boolean}\PYG{o}{\PYGZgt{}}\PYG{p}{().}\PYG{n+na}{apply} \PYG{p}{\PYGZob{}} \PYG{n}{value} \PYG{o}{=} \PYG{p}{(}\PYG{k+kc}{false}\PYG{p}{)\PYGZcb{}}

    \PYG{c+c1}{// raw data get in bluetooth connection}
    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}rawDataRoll}\PYG{p}{:} \PYG{k+kt}{Int} \PYG{o}{=} \PYG{l+m}{0}
    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}rawDataPitch}\PYG{p}{:} \PYG{k+kt}{Int} \PYG{o}{=} \PYG{l+m}{0}
    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}rawDataYaw}\PYG{p}{:} \PYG{k+kt}{Int} \PYG{o}{=} \PYG{l+m}{0}
    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}rawDataCRC}\PYG{p}{:} \PYG{k+kt}{Int} \PYG{o}{=} \PYG{l+m}{0}
    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}rawDataError}\PYG{p}{:} \PYG{k+kt}{Boolean} \PYG{o}{=} \PYG{k+kc}{false}

    \PYG{c+c1}{// data converted from bluetooth = raw/10}
    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}dataRoll} \PYG{o}{=} \PYG{n}{MutableLiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Float}\PYG{o}{\PYGZgt{}}\PYG{p}{()}
    \PYG{k+kd}{val} \PYG{n+nv}{dataRoll}\PYG{p}{:} \PYG{n}{LiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Float}\PYG{o}{\PYGZgt{}}
        \PYG{k}{get}\PYG{p}{()} \PYG{o}{=} \PYG{n}{\PYGZus{}dataRoll}

    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}dataPitch} \PYG{o}{=} \PYG{n}{MutableLiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Float}\PYG{o}{\PYGZgt{}}\PYG{p}{()}
    \PYG{k+kd}{val} \PYG{n+nv}{dataPitch}\PYG{p}{:} \PYG{n}{LiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Float}\PYG{o}{\PYGZgt{}}
        \PYG{k}{get}\PYG{p}{()} \PYG{o}{=} \PYG{n}{\PYGZus{}dataPitch}

    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}dataYaw} \PYG{o}{=} \PYG{n}{MutableLiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Float}\PYG{o}{\PYGZgt{}}\PYG{p}{()}
    \PYG{k+kd}{val} \PYG{n+nv}{dataYaw}\PYG{p}{:} \PYG{n}{LiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Float}\PYG{o}{\PYGZgt{}}
        \PYG{k}{get}\PYG{p}{()} \PYG{o}{=} \PYG{n}{\PYGZus{}dataYaw}

    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}dataError1} \PYG{o}{=} \PYG{n}{MutableLiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Boolean}\PYG{o}{\PYGZgt{}}\PYG{p}{()}
    \PYG{k+kd}{val} \PYG{n+nv}{dataError1}\PYG{p}{:} \PYG{n}{LiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Boolean}\PYG{o}{\PYGZgt{}}
        \PYG{k}{get}\PYG{p}{()} \PYG{o}{=} \PYG{n}{\PYGZus{}dataError1}

    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{\PYGZus{}updatedHandle} \PYG{o}{=} \PYG{n}{MutableLiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Boolean}\PYG{o}{\PYGZgt{}}\PYG{p}{()}
    \PYG{k+kd}{val} \PYG{n+nv}{updatedHandle}\PYG{p}{:} \PYG{n}{LiveData}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{Boolean}\PYG{o}{\PYGZgt{}}
        \PYG{k}{get}\PYG{p}{()} \PYG{o}{=} \PYG{n}{\PYGZus{}updatedHandle}

    \PYG{c+c1}{// buffer read in bluetooth}
    \PYG{k+kd}{var} \PYG{n+nv}{stringBuffer}\PYG{p}{:} \PYG{k+kt}{String} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0,0,0,0\PYGZdq{}}

    \PYG{c+c1}{// bluetooth address of device}
    \PYG{k+kd}{private} \PYG{k+kd}{var} \PYG{n+nv}{mmDeviceMAC}\PYG{p}{:} \PYG{k+kt}{String} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}}

    \PYG{c+c1}{// thread that read bluetooth buffer data}
    \PYG{k+kd}{lateinit} \PYG{k+kd}{var} \PYG{n+nv}{RunnableThread}\PYG{p}{:} \PYG{n}{ConnectedThread}

    \PYG{k}{init} \PYG{p}{\PYGZob{}}
        \PYG{n}{\PYGZus{}mmIsConnected}\PYG{p}{.}\PYG{n+na}{value} \PYG{o}{=} \PYG{k+kc}{null}
        \PYG{n}{\PYGZus{}updatedHandle}\PYG{p}{.}\PYG{n+na}{value} \PYG{o}{=} \PYG{k+kc}{false}
        \PYG{n}{\PYGZus{}calibratingCompass}\PYG{p}{.}\PYG{n+na}{value} \PYG{o}{=} \PYG{k+kc}{false}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{// The Handler that gets information back from the BluetoothService}
    \PYG{k+kd}{private} \PYG{k+kd}{val} \PYG{n+nv}{handler} \PYG{o}{=} \PYG{k}{object} \PYG{p}{:} \PYG{n+nc}{Handler}\PYG{p}{(}\PYG{n}{Looper}\PYG{p}{.}\PYG{n+na}{getMainLooper}\PYG{p}{())} \PYG{p}{\PYGZob{}}
        \PYG{k+kd}{override} \PYG{k+kd}{fun} \PYG{n+nf}{handleMessage}\PYG{p}{(}\PYG{n}{msg}\PYG{p}{:} \PYG{n}{Message}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k+kd}{val} \PYG{n+nv}{bundle}\PYG{p}{:} \PYG{n}{Bundle} \PYG{o}{=} \PYG{n}{msg}\PYG{p}{.}\PYG{n+na}{data}

            \PYG{c+c1}{// get buffer String}
            \PYG{c+c1}{// println(stringBuffer)}
            \PYG{n}{stringBuffer} \PYG{o}{=} \PYG{n}{bundle}\PYG{p}{.}\PYG{n+na}{getString}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}key1\PYGZdq{}}\PYG{p}{,} \PYG{n}{stringBuffer}\PYG{p}{)}
            \PYG{k+kd}{val} \PYG{n+nv}{dataString} \PYG{o}{=} \PYG{n}{stringBuffer}\PYG{p}{.}\PYG{n+na}{split}\PYG{p}{(}\PYG{l+s}{\PYGZdq{},\PYGZdq{}}\PYG{p}{).}\PYG{n+na}{toTypedArray}\PYG{p}{()}

            \PYG{c+c1}{// check if buffer array have only 4 values}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{dataString}\PYG{p}{.}\PYG{n+na}{size} \PYG{o}{==} \PYG{l+m}{4}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k}{try} \PYG{p}{\PYGZob{}}
                    \PYG{n}{\PYGZus{}rawDataRoll} \PYG{o}{=} \PYG{n}{dataString}\PYG{o}{[}\PYG{l+m}{0}\PYG{o}{]}\PYG{p}{.}\PYG{n+na}{toInt}\PYG{p}{()}
                    \PYG{n}{\PYGZus{}rawDataPitch} \PYG{o}{=} \PYG{n}{dataString}\PYG{o}{[}\PYG{l+m}{1}\PYG{o}{]}\PYG{p}{.}\PYG{n+na}{toInt}\PYG{p}{()}
                    \PYG{n}{\PYGZus{}rawDataYaw} \PYG{o}{=} \PYG{n}{dataString}\PYG{o}{[}\PYG{l+m}{2}\PYG{o}{]}\PYG{p}{.}\PYG{n+na}{toInt}\PYG{p}{()}
                    \PYG{n}{\PYGZus{}rawDataCRC} \PYG{o}{=} \PYG{n}{dataString}\PYG{o}{[}\PYG{l+m}{3}\PYG{o}{]}\PYG{p}{.}\PYG{n+na}{toInt}\PYG{p}{()}
                    \PYG{c+c1}{//\PYGZus{}rawDataError:Boolean = dataString[0].toInt()}
                \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{Exception}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                    \PYG{n}{Log}\PYG{p}{.}\PYG{n+na}{e}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}DEBUGCONNECTION\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}Data Values with error\PYGZdq{}}\PYG{p}{,} \PYG{n}{e}\PYG{p}{)}
                \PYG{p}{\PYGZcb{}}
                \PYG{c+c1}{// launch another thread for update UI values IF this values match CRC}
                \PYG{c+c1}{// CRC is just a sum with the other values}
                \PYG{n}{thread} \PYG{p}{\PYGZob{}}
                    \PYG{k}{if} \PYG{p}{((}\PYG{n}{\PYGZus{}rawDataRoll} \PYG{o}{+} \PYG{n}{\PYGZus{}rawDataPitch} \PYG{o}{+} \PYG{n}{\PYGZus{}rawDataYaw}\PYG{p}{)} \PYG{o}{==} \PYG{n}{\PYGZus{}rawDataCRC}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{//updateWriteBuffer(\PYGZdq{}0\PYGZdq{})}
                        \PYG{n}{\PYGZus{}dataRoll}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{n}{\PYGZus{}rawDataRoll}\PYG{p}{.}\PYG{n+na}{toFloat}\PYG{p}{()} \PYG{o}{/} \PYG{l+m}{10}\PYG{p}{)}
                        \PYG{n}{\PYGZus{}dataPitch}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{n}{\PYGZus{}rawDataPitch}\PYG{p}{.}\PYG{n+na}{toFloat}\PYG{p}{()} \PYG{o}{/} \PYG{l+m}{10}\PYG{p}{)}
                        \PYG{n}{\PYGZus{}dataYaw}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{n}{\PYGZus{}rawDataYaw}\PYG{p}{.}\PYG{n+na}{toFloat}\PYG{p}{()} \PYG{o}{/} \PYG{l+m}{10}\PYG{p}{)}
                        \PYG{n}{\PYGZus{}updatedHandle}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{o}{!}\PYG{n}{\PYGZus{}updatedHandle}\PYG{p}{.}\PYG{n+na}{value}\PYG{o}{!!}\PYG{p}{)}
                        \PYG{n}{\PYGZus{}calibratingCompass}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{k+kc}{false}\PYG{p}{)}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}\PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{dataString}\PYG{p}{.}\PYG{n+na}{size} \PYG{o}{==} \PYG{l+m}{2}\PYG{p}{)\PYGZob{}}
                \PYG{n}{thread} \PYG{p}{\PYGZob{}}
                    \PYG{k}{if} \PYG{p}{(}\PYG{n}{dataString}\PYG{o}{[}\PYG{l+m}{0}\PYG{o}{]} \PYG{o}{==} \PYG{n}{dataString}\PYG{o}{[}\PYG{l+m}{1}\PYG{o}{]}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{k}{if}\PYG{p}{(}\PYG{n}{dataString}\PYG{o}{[}\PYG{l+m}{0}\PYG{o}{]} \PYG{o}{==} \PYG{l+s}{\PYGZdq{}s\PYGZdq{}}\PYG{p}{)\PYGZob{}}
                            \PYG{n}{trackingStars}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{k+kc}{true}\PYG{p}{)}
                            \PYG{n}{updateWriteBuffer}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}1\PYGZdq{}}\PYG{p}{)}
                        \PYG{p}{\PYGZcb{}}\PYG{k}{else} \PYG{k}{if}\PYG{p}{(}\PYG{n}{dataString}\PYG{o}{[}\PYG{l+m}{0}\PYG{o}{]} \PYG{o}{==} \PYG{l+s}{\PYGZdq{}n\PYGZdq{}}\PYG{p}{)\PYGZob{}}
                            \PYG{n}{trackingStars}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{k+kc}{false}\PYG{p}{)}
                            \PYG{n}{updateWriteBuffer}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}2\PYGZdq{}}\PYG{p}{)}
                        \PYG{p}{\PYGZcb{}}\PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{dataString}\PYG{o}{[}\PYG{l+m}{0}\PYG{o}{]} \PYG{o}{==} \PYG{l+s}{\PYGZdq{}c\PYGZdq{}}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                            \PYG{n}{\PYGZus{}calibratingCompass}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{k+kc}{true}\PYG{p}{)}
                            \PYG{n}{updateWriteBuffer}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}3\PYGZdq{}}\PYG{p}{)}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Connect with a bluetooth device specified by your address}
\PYG{c+cm}{     * Launch this in a separated thread}
\PYG{c+cm}{     * @param DeviceMAC that is the bluetooth address}
\PYG{c+cm}{     */}
    \PYG{k+kd}{fun} \PYG{n+nf}{connect}\PYG{p}{(}\PYG{n}{DeviceMAC}\PYG{p}{:} \PYG{k+kt}{String}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{thread} \PYG{p}{\PYGZob{}}
            \PYG{k}{try} \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{\PYGZus{}mmIsConnected}\PYG{p}{.}\PYG{n+na}{value} \PYG{o}{!=} \PYG{k+kc}{true}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                    \PYG{n}{mmDeviceMAC} \PYG{o}{=} \PYG{n}{DeviceMAC}
                    \PYG{n}{RunnableThread} \PYG{o}{=} \PYG{n}{ConnectedThread}\PYG{p}{(}\PYG{n}{DeviceMAC}\PYG{p}{,} \PYG{n}{handler}\PYG{p}{)}
                    \PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{connectThread}\PYG{p}{()}
                    \PYG{n}{\PYGZus{}mmIsConnected}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{mmThreadIsConnected}\PYG{p}{)}
                    \PYG{k}{if} \PYG{p}{(}\PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{mmThreadIsConnected}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{run}\PYG{p}{()}
                    \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
                        \PYG{n}{\PYGZus{}mmIsConnected}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{k+kc}{false}\PYG{p}{)}
                    \PYG{p}{\PYGZcb{}}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{java}\PYG{p}{.}\PYG{n+na}{lang}\PYG{p}{.}\PYG{n+na}{Exception}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{e}\PYG{p}{.}\PYG{n+na}{printStackTrace}\PYG{p}{()}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Disconnect with the current bluetooth device}
\PYG{c+cm}{     * Launch this in a separated thread}
\PYG{c+cm}{     */}
    \PYG{k+kd}{fun} \PYG{n+nf}{disconnect}\PYG{p}{()} \PYG{p}{\PYGZob{}}
        \PYG{n}{thread}\PYG{p}{\PYGZob{}}
            \PYG{k}{try} \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{\PYGZus{}mmIsConnected}\PYG{p}{.}\PYG{n+na}{value} \PYG{o}{==} \PYG{k+kc}{true}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                    \PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{disconnectThread}\PYG{p}{()}
                    \PYG{n}{\PYGZus{}mmIsConnected}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{mmThreadIsConnected}\PYG{p}{)}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{\PYGZus{}mmIsConnected}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{mmThreadIsConnected}\PYG{p}{)}
            \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{java}\PYG{p}{.}\PYG{n+na}{lang}\PYG{p}{.}\PYG{n+na}{Exception}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{e}\PYG{p}{.}\PYG{n+na}{printStackTrace}\PYG{p}{()}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+cm}{/**}
\PYG{c+cm}{     * Reconnect with a bluetooth device specified by your address}
\PYG{c+cm}{     * Launch this in a separated thread}
\PYG{c+cm}{     */}
    \PYG{k+kd}{fun} \PYG{n+nf}{reconnect}\PYG{p}{()} \PYG{p}{\PYGZob{}}
        \PYG{n}{thread}\PYG{p}{\PYGZob{}}
            \PYG{k}{try} \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{\PYGZus{}mmIsConnected}\PYG{p}{.}\PYG{n+na}{value} \PYG{o}{==} \PYG{k+kc}{true}\PYG{p}{)} \PYG{p}{\PYGZob{}} \PYG{c+c1}{//disconect just if it is connected}
                    \PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{disconnectThread}\PYG{p}{()}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{RunnableThread} \PYG{o}{=} \PYG{n}{ConnectedThread}\PYG{p}{(}\PYG{n}{mmDeviceMAC}\PYG{p}{,} \PYG{n}{handler}\PYG{p}{)}
                \PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{connectThread}\PYG{p}{()}
                \PYG{n}{\PYGZus{}mmIsConnected}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{mmThreadIsConnected}\PYG{p}{)}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{mmThreadIsConnected}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                    \PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{run}\PYG{p}{()}
                \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
                    \PYG{n}{\PYGZus{}mmIsConnected}\PYG{p}{.}\PYG{n+na}{postValue}\PYG{p}{(}\PYG{k+kc}{false}\PYG{p}{)}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{java}\PYG{p}{.}\PYG{n+na}{lang}\PYG{p}{.}\PYG{n+na}{Exception}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{e}\PYG{p}{.}\PYG{n+na}{printStackTrace}\PYG{p}{()}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{k+kd}{fun} \PYG{n+nf}{updateWriteBuffer}\PYG{p}{(}\PYG{n}{buffer}\PYG{p}{:} \PYG{k+kt}{String}\PYG{p}{)\PYGZob{}}
        \PYG{n}{RunnableThread}\PYG{p}{.}\PYG{n+na}{writeBuffer} \PYG{o}{=} \PYG{n}{buffer}
    \PYG{p}{\PYGZcb{}}

    \PYG{c+c1}{//class that stands for run a thread for read and write in bluetooth device}
    \PYG{k+kd}{inner} \PYG{k+kd}{class} \PYG{n+nc}{ConnectedThread}\PYG{p}{(}\PYG{k+kd}{var} \PYG{n+nv}{DeviceMAC}\PYG{p}{:} \PYG{k+kt}{String}\PYG{p}{,} \PYG{k+kd}{var} \PYG{n+nv}{handler}\PYG{p}{:} \PYG{n}{Handler}\PYG{p}{)} \PYG{p}{:} \PYG{n}{Thread}\PYG{p}{()} \PYG{p}{\PYGZob{}}

        \PYG{c+c1}{// bluetooth variables}
        \PYG{k+kd}{private} \PYG{k+kd}{lateinit} \PYG{k+kd}{var} \PYG{n+nv}{mmDevice}\PYG{p}{:} \PYG{n}{BluetoothDevice}
        \PYG{k+kd}{private} \PYG{k+kd}{lateinit} \PYG{k+kd}{var} \PYG{n+nv}{mmAdapter}\PYG{p}{:} \PYG{n}{BluetoothAdapter}
        \PYG{k+kd}{private} \PYG{k+kd}{lateinit} \PYG{k+kd}{var} \PYG{n+nv}{mmInStream}\PYG{p}{:} \PYG{n}{InputStream}
        \PYG{k+kd}{private} \PYG{k+kd}{lateinit} \PYG{k+kd}{var} \PYG{n+nv}{mmOutStream}\PYG{p}{:} \PYG{n}{OutputStream}
        \PYG{k+kd}{lateinit} \PYG{k+kd}{var} \PYG{n+nv}{mmSocket}\PYG{p}{:} \PYG{n}{BluetoothSocket}
        \PYG{k+kd}{var} \PYG{n+nv}{writeBuffer} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}0\PYGZdq{}}

        \PYG{c+c1}{//state of connection}
        \PYG{k+kd}{var} \PYG{n+nv}{mmThreadIsConnected} \PYG{o}{=} \PYG{k+kc}{false}
        \PYG{k+kd}{var} \PYG{n+nv}{mmThreadIsDesconnecting} \PYG{o}{=} \PYG{k+kc}{false}

        \PYG{c+c1}{// Unique UUID for this application}
        \PYG{c+c1}{// https://stackoverflow.com/questions/32130529/}
        \PYG{k+kd}{val} \PYG{n+nv}{myUUID}\PYG{p}{:} \PYG{n}{UUID? }\PYG{o}{=} \PYG{n}{UUID}\PYG{p}{.}\PYG{n+na}{fromString}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}00001101\PYGZhy{}0000\PYGZhy{}1000\PYGZhy{}8000\PYGZhy{}00805F9B34FB\PYGZdq{}}\PYG{p}{)}

        \PYG{c+c1}{// runs the thread for communicate with HC05}
        \PYG{k+kd}{override} \PYG{k+kd}{fun} \PYG{n+nf}{run}\PYG{p}{()} \PYG{p}{\PYGZob{}}

            \PYG{c+c1}{// check if it still connected}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{mmThreadIsConnected} \PYG{o}{==} \PYG{k+kc}{true}\PYG{p}{)} \PYG{p}{\PYGZob{}}

                \PYG{k+kd}{var} \PYG{n+nv}{getWriteTime}\PYG{p}{:} \PYG{k+kt}{Long} \PYG{o}{=} \PYG{n}{System}\PYG{p}{.}\PYG{n+na}{currentTimeMillis}\PYG{p}{()}
                \PYG{k+kd}{val} \PYG{n+nv}{buffer} \PYG{o}{=} \PYG{n}{ByteArray}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{)}
                \PYG{k+kd}{var} \PYG{n+nv}{bytes}\PYG{p}{:} \PYG{k+kt}{Int}
                \PYG{k+kd}{var} \PYG{n+nv}{readMessage} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}}
                \PYG{k+kd}{var} \PYG{n+nv}{readChar}\PYG{p}{:} \PYG{k+kt}{String}

                \PYG{k+kd}{var} \PYG{n+nv}{getTime}\PYG{p}{:} \PYG{k+kt}{Long} \PYG{o}{=} \PYG{n}{System}\PYG{p}{.}\PYG{n+na}{currentTimeMillis}\PYG{p}{()}
                \PYG{k}{while} \PYG{p}{(}\PYG{k+kc}{true}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                    \PYG{c+c1}{// Keep listening to the InputStream until an exception occurs.}
                    \PYG{k}{try} \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{//ensure that the buffer is allways clean}
                        \PYG{c+c1}{//delaytime is the delay that ui wait for read next buffer.}
                        \PYG{k+kd}{var} \PYG{n+nv}{delaytime} \PYG{o}{=} \PYG{l+m}{10}
                        \PYG{k}{if} \PYG{p}{((}\PYG{n}{mmInStream}\PYG{p}{.}\PYG{n+na}{available}\PYG{p}{()} \PYG{o}{\PYGZgt{}} \PYG{l+m}{1000}\PYG{p}{))} \PYG{p}{\PYGZob{}}
                            \PYG{c+c1}{// if the buffer is overload, i.e, is bigger then 230 bytes,}
                            \PYG{c+c1}{// reduce the delay so the UI can update faster enough}
                            \PYG{n}{delaytime} \PYG{o}{=} \PYG{l+m}{1}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{c+c1}{//if available and also get a delay between reeds}
                        \PYG{k}{if} \PYG{p}{((}\PYG{n}{mmInStream}\PYG{p}{.}\PYG{n+na}{available}\PYG{p}{()} \PYG{o}{\PYGZgt{}} \PYG{l+m}{0}\PYG{p}{)} \PYG{o}{\PYGZam{}\PYGZam{}}
                            \PYG{p}{((}\PYG{n}{System}\PYG{p}{.}\PYG{n+na}{currentTimeMillis}\PYG{p}{()} \PYG{o}{\PYGZhy{}} \PYG{n}{getTime}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{n}{delaytime}\PYG{p}{)}
                        \PYG{p}{)} \PYG{p}{\PYGZob{}}

                            \PYG{n}{bytes} \PYG{o}{=} \PYG{n}{mmInStream}\PYG{p}{.}\PYG{n+na}{read}\PYG{p}{(}\PYG{n}{buffer}\PYG{p}{)} \PYG{c+c1}{//read bytes from input buffer}
                            \PYG{n}{readChar} \PYG{o}{=} \PYG{k+kt}{String}\PYG{p}{(}\PYG{n}{buffer}\PYG{p}{,} \PYG{l+m}{0}\PYG{p}{,} \PYG{n}{bytes}\PYG{p}{)} \PYG{c+c1}{//get Char}

                            \PYG{c+c1}{//if char isnt \PYGZsq{}\PYGZbs{}n\PYGZsq{} then join all char recieved,}
                            \PYG{c+c1}{// mounting the data string. Stop when \PYGZsq{}\PYGZbs{}n\PYGZsq{} and send it through handler}
                            \PYG{k}{if} \PYG{p}{(}\PYG{n}{readChar} \PYG{o}{==} \PYG{l+s}{\PYGZdq{}\PYGZbs{}n\PYGZdq{}}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                                \PYG{n}{getTime} \PYG{o}{=} \PYG{n}{System}\PYG{p}{.}\PYG{n+na}{currentTimeMillis}\PYG{p}{()}
                                \PYG{k+kd}{val} \PYG{n+nv}{readMsg} \PYG{o}{=} \PYG{n}{handler}\PYG{p}{.}\PYG{n+na}{obtainMessage}\PYG{p}{(}\PYG{n}{MESSAGE\PYGZus{}READ}\PYG{p}{)}
                                \PYG{k+kd}{val} \PYG{n+nv}{bundle} \PYG{o}{=} \PYG{n}{Bundle}\PYG{p}{()}
                                \PYG{n}{bundle}\PYG{p}{.}\PYG{n+na}{putString}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}key1\PYGZdq{}}\PYG{p}{,} \PYG{n}{readMessage}\PYG{p}{)}
                                \PYG{n}{readMsg}\PYG{p}{.}\PYG{n+na}{data} \PYG{o}{=} \PYG{n}{bundle}
                                \PYG{n}{readMsg}\PYG{p}{.}\PYG{n+na}{sendToTarget}\PYG{p}{()}
                                \PYG{n}{readMessage} \PYG{o}{=} \PYG{l+s}{\PYGZdq{}\PYGZdq{}}
                            \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
                                \PYG{n}{readMessage} \PYG{o}{+=} \PYG{n}{readChar}
                            \PYG{p}{\PYGZcb{}}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{IOException}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{n}{Log}\PYG{p}{.}\PYG{n+na}{e}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}DEBUGCONNECTION\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}Input stream was disconnected\PYGZdq{}}\PYG{p}{)}
                        \PYG{c+c1}{// in case of error, start disconnect if it not started}
                        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{mmThreadIsDesconnecting}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                            \PYG{n}{mmThreadIsDesconnecting} \PYG{o}{=} \PYG{k+kc}{true}
                            \PYG{n}{disconnect}\PYG{p}{()}
                        \PYG{p}{\PYGZcb{}}
                        \PYG{k}{break}
                    \PYG{p}{\PYGZcb{}}

                    \PYG{c+c1}{// launch another thread to write in output buffer}
                    \PYG{n}{thread} \PYG{p}{\PYGZob{}}
                        \PYG{c+c1}{// send messages with 2Hz of speed}
                        \PYG{k}{if} \PYG{p}{((}\PYG{n}{System}\PYG{p}{.}\PYG{n+na}{currentTimeMillis}\PYG{p}{()} \PYG{o}{\PYGZhy{}} \PYG{n}{getWriteTime}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m}{500}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                            \PYG{n}{getWriteTime} \PYG{o}{=} \PYG{n}{System}\PYG{p}{.}\PYG{n+na}{currentTimeMillis}\PYG{p}{()}
                            \PYG{n}{write}\PYG{p}{(}\PYG{n}{writeBuffer}\PYG{p}{.}\PYG{n+na}{encodeToByteArray}\PYG{p}{())}
                        \PYG{p}{\PYGZcb{}}
                    \PYG{p}{\PYGZcb{}}

                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// Call this from the main activity to send data to the remote device.}
        \PYG{k+kd}{fun} \PYG{n+nf}{write}\PYG{p}{(}\PYG{n}{bytes}\PYG{p}{:} \PYG{n}{ByteArray}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{try} \PYG{p}{\PYGZob{}}
                \PYG{n}{mmOutStream}\PYG{p}{.}\PYG{n+na}{write}\PYG{p}{(}\PYG{n}{bytes}\PYG{p}{)}
            \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{IOException}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{Log}\PYG{p}{.}\PYG{n+na}{e}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}DEBUGCONNECTION\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}Error occurred when sending data\PYGZdq{}}\PYG{p}{)}

                \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{mmThreadIsDesconnecting}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                    \PYG{n}{mmThreadIsDesconnecting} \PYG{o}{=} \PYG{k+kc}{true}
                    \PYG{n}{disconnect}\PYG{p}{()}
                \PYG{p}{\PYGZcb{}}

                \PYG{k}{return}
            \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{Exception}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{Log}\PYG{p}{.}\PYG{n+na}{e}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}DEBUGCONNECTION\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}Error occurred when sending data\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// This function check if the phone has bt adapter}
        \PYG{c+c1}{// and then connect with device using the UUID}
        \PYG{k+kd}{fun} \PYG{n+nf}{connectThread}\PYG{p}{()} \PYG{p}{\PYGZob{}}
            \PYG{k}{if} \PYG{p}{(}\PYG{n}{BluetoothAdapter}\PYG{p}{.}\PYG{n+na}{getDefaultAdapter}\PYG{p}{()} \PYG{o}{!=} \PYG{k+kc}{null}\PYG{p}{)} \PYG{p}{\PYGZob{}}

                \PYG{n}{mmAdapter} \PYG{o}{=} \PYG{n}{BluetoothAdapter}\PYG{p}{.}\PYG{n+na}{getDefaultAdapter}\PYG{p}{()}
                \PYG{n}{mmThreadIsDesconnecting} \PYG{o}{=} \PYG{k+kc}{false}

                \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{mmAdapter}\PYG{p}{.}\PYG{n+na}{isEnabled}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                    \PYG{k}{throw} \PYG{n}{Exception}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Bluetooth adapter not found or not enabled!\PYGZdq{}}\PYG{p}{)}
                \PYG{p}{\PYGZcb{}}

                \PYG{n}{mmDevice} \PYG{o}{=} \PYG{n}{mmAdapter}\PYG{p}{.}\PYG{n+na}{getRemoteDevice}\PYG{p}{(}\PYG{n}{DeviceMAC}\PYG{p}{)}
                \PYG{n}{mmSocket} \PYG{o}{=} \PYG{n}{mmDevice}\PYG{p}{.}\PYG{n+na}{createRfcommSocketToServiceRecord}\PYG{p}{(}\PYG{n}{myUUID}\PYG{p}{)}

                \PYG{k}{try} \PYG{p}{\PYGZob{}}
                    \PYG{n}{mmSocket}\PYG{p}{.}\PYG{n+na}{connect}\PYG{p}{()}
                    \PYG{n}{mmThreadIsConnected} \PYG{o}{=} \PYG{n}{mmSocket}\PYG{p}{.}\PYG{n+na}{isConnected}
                    \PYG{c+c1}{// Cancel discovery because it otherwise slows down the connection.}
                    \PYG{n}{mmAdapter}\PYG{p}{.}\PYG{n+na}{cancelDiscovery}\PYG{p}{()}
                    \PYG{n}{mmInStream} \PYG{o}{=} \PYG{n}{mmSocket}\PYG{p}{.}\PYG{n+na}{inputStream}
                    \PYG{n}{mmOutStream} \PYG{o}{=} \PYG{n}{mmSocket}\PYG{p}{.}\PYG{n+na}{outputStream}

                \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{IOException}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                    \PYG{n}{mmThreadIsConnected} \PYG{o}{=} \PYG{n}{mmSocket}\PYG{p}{.}\PYG{n+na}{isConnected}
                    \PYG{n}{Log}\PYG{p}{.}\PYG{n+na}{e}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}DEBUGCONNECTION\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}UNABLE TO CONNECT WITH BLUETOOTH DEVICE\PYGZdq{}}\PYG{p}{)}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
                \PYG{n}{Log}\PYG{p}{.}\PYG{n+na}{e}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}DEBUGBLUETOOTH\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}DONT HAVE BLUETOOTH ADAPTER\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+c1}{// disconnect stream, socket and bluetooth device}
        \PYG{k+kd}{fun} \PYG{n+nf}{disconnectThread}\PYG{p}{()} \PYG{p}{\PYGZob{}}
            \PYG{k}{try} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// close input}
                \PYG{n}{mmInStream}\PYG{p}{.}\PYG{n+na}{close}\PYG{p}{()}
            \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{IOException}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{e}\PYG{p}{.}\PYG{n+na}{printStackTrace}\PYG{p}{()}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{try} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// close output}
                \PYG{n}{mmOutStream}\PYG{p}{.}\PYG{n+na}{close}\PYG{p}{()}
            \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{IOException}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{e}\PYG{p}{.}\PYG{n+na}{printStackTrace}\PYG{p}{()}
            \PYG{p}{\PYGZcb{}}
            \PYG{k}{try} \PYG{p}{\PYGZob{}} \PYG{c+c1}{// close socket}
                \PYG{n}{mmSocket}\PYG{p}{.}\PYG{n+na}{close}\PYG{p}{()}
            \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{IOException}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{e}\PYG{p}{.}\PYG{n+na}{printStackTrace}\PYG{p}{()}
                \PYG{n}{Log}\PYG{p}{.}\PYG{n+na}{e}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}DEBUGCONNECTION\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}Could not close the connect socket\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZcb{}} \PYG{k}{catch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{:} \PYG{n}{Exception}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{e}\PYG{p}{.}\PYG{n+na}{printStackTrace}\PYG{p}{()}
                \PYG{n}{Log}\PYG{p}{.}\PYG{n+na}{e}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}DEBUGCONNECTION\PYGZdq{}}\PYG{p}{,} \PYG{l+s}{\PYGZdq{}Could not close the connect socket\PYGZdq{}}\PYG{p}{)}
            \PYG{p}{\PYGZcb{}}
            \PYG{c+c1}{// update state}
            \PYG{n}{mmThreadIsConnected} \PYG{o}{=} \PYG{n}{mmSocket}\PYG{p}{.}\PYG{n+na}{isConnected}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{Verbatim}
